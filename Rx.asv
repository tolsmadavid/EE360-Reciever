% Rx.m - Decodes a Transmitted signal
% David Tolsma
[decodedtext, y] = Rx(r, rolloff, desireduser)

close all
clear

addpath('C:\Users\David\Documents\MATLAB\MatLab Files')
%load easy.mat
load medium.mat
%load hard.mat


%Debug Bits

debugPll = 0;
ssrcDebug = 0;
IDdebug = 0;
TSdebug = 0;
RTSdebug = 1;

%Parameters
    
    interFreq = 2e6;
    sampleFreq = 850e3;
    Ts = 1/sampleFreq;
    symbolPeriod = 6.4e-6;
    srrcWidth = 8;
    overSampleFactor = symbolPeriod/Ts;
    

%Carrier Recovery

    %Carrier Preprocessing
        ppSquaredR = r.^2;
        ppFilterOrder = 500;
        ppFilterFreq = [0 .55 .57 .61 .63 1];
        ppFilterMags = [0 0 1 1 0 0];
        ppFilterB = firpm(ppFilterOrder, ppFilterFreq, ppFilterMags);
        ppRPreProcess = filter(ppFilterB, 1, ppSquaredR);

    %Carrier Frequency Recovory
        ppFFTrPreProcess = fft(ppRPreProcess);
        [ppM, ppImax] = max(abs(ppFFTrPreProcess(1:floor(end/2))));
        ppSsf = (0:length(ppRPreProcess))/(Ts*length(ppRPreProcess));
        ppFreqS = ppSsf(ppImax);
        ppPhaseP=angle(ppFFTrPreProcess(ppImax));
        [ppIR, ppF] = freqz(ppFilterB,1,length(ppFFTrPreProcess), sampleFreq);
        [ppMi, ppIm] = min(abs(ppF - ppFreqS));
        ppPhaseBPF = angle(ppIR(ppIm));
        ppPhaseS = mod(ppPhaseP - ppPhaseBPF, pi);

    %Dual PLLs
        pllMu1= 0.01; pllMu2 = 0.0005;                  % algorithm stepsizes
        pllF0=300000;                            % assumed freq at receiver
        pllT = 0:Ts:length(r)*Ts-Ts;
        
        pllTh1 = zeros(1, length(r));
        pllTh2 = zeros(1, length(r));
        for k=1:length(r)-1                      % combine top PLL th1
          pllTh1(k+1)=pllTh1(k)-pllMu1*ppRPreProcess(k)*sin(4*pi*pllF0*pllT(k)+2*pllTh1(k)+ppPhaseBPF);           
          pllTh2(k+1)=pllTh2(k)-pllMu2*ppRPreProcess(k)*sin(4*pi*pllF0*pllT(k)+2*pllTh1(k)+2*pllTh2(k)+ppPhaseBPF);  
        end
    
%Demodulation
    demodF0=300000;                            % assumed freq at receiver

    demodT = 0:Ts:length(r)*Ts - Ts;
    demodCos = cos(2*pi*demodF0*demodT + pllTh1 + pllTh2);
    %demodCos = cos(2*pi*demodF0*demodT);
    demodR = demodCos.*r';

    demodFl=200; demodFf=[0 .2 .25 1]; demodFa=[1 1 0 0];
    demodH=firpm(demodFl,demodFf,demodFa);                    % LPF design
    demodFilteredR = filter(demodH, 1, demodR);

    if(debugPll)
        figure('Name', 'Th1, Th2, DemodR')
        subplot(3,1,1)
        plot(pllTh1)
        subplot(3,1,2)
        plot(pllTh2)
        subplot(3,1,3)
        plot(demodFilteredR)
    end
        
%Pulse Shape Matched Filtering
    psmfPulseShape = srrc(srrcWidth/2, rolloff, (symbolPeriod/(Ts)));
    psmfRFiltered = conv(demodFilteredR, psmfPulseShape);
    if(ssrcDebug)    
        figure('Name', 'Output of Pulse Shape Matched Filtering');
        plot(psmfRFiltered);
    end
    
    %psmfRFiltered = psmfRFiltered*1.2;
%Interpolator Downsampler
    IDtnow = (srrcWidth/2)*overSampleFactor+1;
    IDtau = 0;
    IDxs = zeros(1,length(r));
    IDtauSave = zeros(1, length(r));
    IDi = 0;
    IDmuDD = 0.07;
    IDmuOP = 0.07;
    IDdelta = .1;

    
    while IDtnow < length(r)- 2*(srrcWidth/2)*overSampleFactor
        IDi = IDi + 1;
        IDxs(IDi) = interpsinc(psmfRFiltered, IDtnow + IDtau, (srrcWidth/2));
        IDx_deltap=interpsinc(psmfRFiltered,IDtnow+IDtau+IDdelta,(srrcWidth/2)); % value to right
        IDx_deltam=interpsinc(psmfRFiltered,IDtnow+IDtau-IDdelta,(srrcWidth/2)); % value to left
        
        IDdx = IDx_deltap-IDx_deltam;
        %IDtau = IDtau + IDmu*IDdx*IDxs(IDi);

        IDdx=IDx_deltap-IDx_deltam;             % numerical derivative
        IDqx=quantalph(IDxs(IDi),[-3,-1,1,3]);  % quantize to alphabet
        %IDtau=IDtau-IDmu*IDdx*(IDqx-IDxs(IDi));         % alg update: DD
        
        IDtau=IDtau - IDmuDD*IDdx*(IDqx-IDxs(IDi)) + ((1.7210e+05-IDtnow)/(1.7210e+05))*IDmuOP*IDdx*IDxs(IDi);
        
        IDtnow=IDtnow+overSampleFactor; 
        IDtausave(IDi)=IDtau;      % save for plotting
    end

    if(IDdebug)
        figure('Name', 'Plot of DD Interpolator')
        subplot(2,1,1), plot(IDxs(1:IDi-2),'b.')        % plot constellation diagram
        title('constellation diagram');
        ylabel('estimated symbol values')
        subplot(2,1,2), plot(IDtausave(1:IDi-2))        % plot trajectory of tau
        ylabel('offset estimates'), xlabel('iterations')
    end

%Find Training Sequences
    %Create training sequence vector
        TS = 'A0Oh well whatever Nevermind';
        TSpam = letters2pam2(TS);
        [TScorr, TScorrLags] = xcorr(IDxs, TSpam); %Find correlation between preamble and XS
        
        [TScorrPeaksMags, ~] = findpeaks(TScorr, 'NPeaks', 11, 'MinPeakDistance', 1000, 'MinPeakHeight', 600);
        if(isempty(TScorrPeaksMags))
            TScorr = -TScorr;
            IDxs = -IDxs;
        end
            
        [TScorrPeaksMags, TScorrPeaksLocs] = findpeaks(TScorr, 'NPeaks', 11, 'MinPeakDistance', 1000, 'MinPeakHeight', 600);
        TSxsPeakLocs = TScorrLags(TScorrPeaksLocs); %Locations of preamble starts in terms of XS
        
        if(TSdebug)
            figure('Name', 'Correlation of Training Sequence')
            stem(TScorr);

            figure('Name', 'TScorr Peaks')
            stem(TScorrLags(TScorrPeaksLocs), TScorrPeaksMags);
        end
        
%Equalizer
    %Chop TSxs into blocks for processing
        EQout = [];
        EQn=20; 
        EQmu=.007; 
        EQdelta=10;             % stepsize and delay delta
        EQf=zeros(EQn,1);           % initialize equalizer at 0
        
        for(EQi = 1:length(TSxsPeakLocs))

            EQr = IDxs(TSxsPeakLocs(EQi):TSxsPeakLocs(EQi) + length(TSpam) - 1);
            EQframe = IDxs(TSxsPeakLocs(EQi):TSxsPeakLocs(EQi)+2870-1);
            
            for EQj=EQn+1:length(TSpam)                  % iterate
                EQrr=EQr(EQj:-1:EQj-EQn+1)';         % vector of received signal
                EQe=TSpam(EQj-EQdelta)-EQrr'*EQf;        % calculate error
                EQf=EQf+EQmu*EQe*EQrr;               % update equalizer coefficients
            end

            EQout = [EQout,conv(EQf,EQframe)];
        end
        
        %figure('Name', 'After EQ')
        %plot(EQout(1:30000), '.');
        
        EQoutQuant = quantalph(EQout,[-3,-1,1,3]); 
 
        
%Re-Correlate

%Find Training Sequences
    %Create training sequence vector
        [RTScorr, RTScorrLags] = xcorr(EQoutQuant, TSpam); %Find correlation between preamble and XS
            
        [RTScorrPeaksMags, RTScorrPeaksLocs] = findpeaks(RTScorr, 'NPeaks', 11, 'MinPeakDistance', 2500, 'MinPeakHeight', 600);
        RTSxsPeakLocs = RTScorrLags(RTScorrPeaksLocs); %Locations of preamble starts in terms of XS
        
        if(RTSdebug)
            figure('Name', 'ReCorrelation of Training Sequence')
            stem(RTScorr);

            figure('Name', 'TScorr Peaks')
            stem(RTScorrLags(RTScorrPeaksLocs), RTScorrPeaksMags);
        end
        
        RTSUser = 3;
        RTSUserOffset = [0, 875, 875*2];
        
        RTSout = [];
        for(RTSi = 1:length(RTSxsPeakLocs))
            RTSout = [RTSout, EQoutQuant(RTSxsPeakLocs(RTSi) + length(TSpam) + 1 + RTSUserOffset(RTSUser): RTSxsPeakLocs(RTSi) + length(TSpam) + RTSUserOffset(RTSUser) + 875)];
        end   
        
        letters = pam2letters2(RTSout)
        
    
    
    
    


